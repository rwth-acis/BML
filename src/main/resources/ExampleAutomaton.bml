Bot(host="localhost", port=8080) {

    OpenAPI pizzaScarf(url="https://pizzascarf.com/api/v3/reviews.json")

    Rasa rasa(url="rasa.com/rasaToken:8000") // Automatically used by messengers

    Telegram telegram(token="myTelegramToken")

    Slack slack(token="mySlackToken")

    Discord discord(token="myDiscordToken")

    RocketChat rocketChat(token="myRocketChatToken")

    /* General State Syntax:
     * <StateType> ID = (intent="<intent>", action=<Action>/<String>/<List<String>/<ResponseObject>/<jumpToState(<State>)>)
     *
     * States can be fall-through when they have no intents. I.e., their reaching is not "guarded" by an intent.
     * Likewise, states do not need actions.
     *
     * Dialogues have a main state (similar to an idle state) that they go back to when a "conversation path" ends
     *
     * Junctions:
     *    someStartName -> A -> {B, C} -> D // -> mainState (this is done implicitly)
     *    Equivalent: A -> B; A -> C; B -> D; C -> D
     *
     * Junctions that need disambiguation:
     *    someStartName -> A -> {B, C} -> {D, E}
     *    Possible disambiguation: B -> {D, E} AND C -> {D, E}
     *
     * jumpToState:
     * The idea of the `jumpToState` builtin function is to provide means to skip intent guards.
     * This can be helpful if we want to repeat a state, e.g.:
     * state A = (intent="foo", action=bar)
     * A -> {B, C -> (action=jumpToState(A))}
     * Here we can go back from C to A without having to have "foo" as a guard
     */
    Dialogue pizzaScarfReview(name="Conversing with a rating bot for PizzaScarf") {
        /*
         * States
         */
        // Should simplify making conversation appear "more vivid" (answer chosen randomly from this list)
        greetings = ["Hi there, fellow human!",
                     "Hi, nice to meet you!",
                     "Hello, a pleasure to meet you!"]

        // "_" intent matches if nothing else matched
        // Takes us back to "main state"
        default notUnderstood = (intent="_", action="Iâ€™m sorry, I didn't understand that, come again please.")

        // We can list several intents
        // initial states are matched from the "main state"
        initial greet = (intent="hello, greet", action=greetings)
        initial options = (intent="intent", action="I'm a simple rating bot, I can submit ratings for you.")

        // Every state, except the state itself points to this
        sink bye = (intent="bye", action="Until next time!")

        response = {
            text = "Please provide your receipt ID. You can find it lorem ipsum ...",
            file = example.jpg
        }
        initial addReview = (intent="review", response)

        state giveRating = (action="How many stars would you like to give?")

        /*
         * Transitions
         */
        addReview -> {
            (intent="receiptId", action=verifyReceiptId) -> giveRating,
            (intent="reject", action="Sorry , I didn't get that. Please specify your receipt ID.") -> (action=jumpToState(addReview))
        }

        giveRating -> {
            (intent="stars", action=postReview),
            (intent="reject", action="Sorry , I didn't get that. Please specify how many stars you would like to give.") -> giveRating
        } -> (action="Would you like to make another review?") -> {
            (intent="yes", action=jumpToState(addReview)),
            (intent="no", action="Okay, thank you. We're looking forward to your next visit!")
        }

        /*
         * Actions
         */
        @Action
        postReview(data) {
            // Build request body
            review = {
                stars = number(data.entity),
                auth = authKey.file
            }
            
            response = pizzaScarf.post(path="/addReview/", body=review)

            // Both "paths" go back to the main state
            if response.code == 200 {
                send("Your review was successfully processed!") // Automatically addresses user from `data`
            } else {
                send("I'm sorry, it seems like there is a problem on our side. Please try again later.")
            }
        }

        @Action
        verifyReceiptId(data) {
            response = pizzaScarf.get(path="/checkReceiptId/", id=data.entity)
            if response.code != 200 {
                send("I'm sorry, but you did not provide a valid receipt id.")
            }
        }
    }

    @Compose(@UserSentMessage, @UserStartedChat) // A composition calls the handler for either event
    messageHandler(data) {
        /*
         * The idea behind the step function is to "advance"/step the automaton according to the input `data`.
         * The automaton will make a transition according to the current state its in and the given input.
         * Hence, the pizzaScarfReview Dialogue component needs to keep track of the current state.
         */
        pizzaScarfReview.step(data);
    }
}
